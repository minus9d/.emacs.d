# -*- mode: snippet -*-
# name: dijkstra
# key: dijkstra
# --
typedef double CostPrecision; // Change me!

static const int           MAX_V = 1001;
static const CostPrecision INF   = INT_MAX;

struct Edge {
  int           to;
  CostPrecision cost;
};

static int           V;         // Init me!
static vector<Edge>  G[MAX_V];  // Init me!
static CostPrecision d[MAX_V];
static int           prev[MAX_V];

void dijkstra(int s) {
  typedef pair<CostPrecision, int> P;
  priority_queue<P, vector<P>, greater<P> > que;
  fill(d, d + V, INF);
  fill(prev, prev + V, -1);
  d[s] = 0;
  que.push(P(0, s));
  while (!que.empty()) {
    P   p = que.top(); que.pop();
    int v = p.second;
    if (d[v] < p.first)
      continue;
    for (int i = 0; i < (int)G[v].size(); i++) {
      Edge e = G[v][i];
      if (d[e.to] > d[v] + e.cost) {
        d[e.to]    = d[v] + e.cost;
        prev[e.to] = v;
        que.push(P(d[e.to], e.to));
      }
    }
  }
}

vector<int> get_path(int t) {
  vector<int> path;

  for (; t != -1; t = prev[t]) {
    path.push_back(t);
  }
  reverse(path.begin(), path.end());
  return path;
}
